import { NextResponse } from 'next/server'
import OpenAI from 'openai'
import { createPrompt, mapFormDataToPrompt, createFineTunePrompt, createContextualPrompt } from '../../../../lib/promptGenerator'
import { requireContentGeneration, handleAuthError } from '../../../../lib/authMiddleware'
import { incrementArticleUsage, incrementArticleAndTokenUsage, canUserGenerateContent } from '../../../../lib/usageTracker'
import { getUserPlanFromDB } from '../../../../lib/permissions'
import { clientPromise } from '../../../../lib/mongodb'

// Inicializar cliente de OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

// Validar que tenemos API key
if (!process.env.OPENAI_API_KEY) {
  console.error('‚ùå OPENAI_API_KEY no configurada')
}

export async function POST(request) {
  console.log('üöÄ Iniciando generaci√≥n de art√≠culo...')
  console.log('üîë API Key configurada:', !!process.env.OPENAI_API_KEY)
  
  // Validar API key temprano
  if (!process.env.OPENAI_API_KEY) {
    console.error('‚ùå OPENAI_API_KEY no est√° configurada')
    return NextResponse.json(
      { error: 'Configuraci√≥n del servidor incompleta' },
      { status: 500 }
    )
  }
  
  try {
    console.log('üîê Verificando autenticaci√≥n y permisos...')
    // Verificar permisos y autenticaci√≥n
    const authResult = await requireContentGeneration(request, 'article')
    console.log('üîê Resultado autenticaci√≥n:', authResult.success ? 'OK' : 'FAIL', authResult.error || '')
    
    if (!authResult.success) {
      console.log('‚ùå Error de autenticaci√≥n:', authResult.error)
      return handleAuthError(authResult)
    }
    
    const user = authResult.user
    const formData = await request.json()
    
    // Validar datos requeridos
    if (!formData.topic || !formData.tone || !formData.length || !formData.objective) {
      console.log('‚ùå Faltan datos requeridos:', {
        topic: !!formData.topic,
        tone: !!formData.tone,
        length: !!formData.length,
        objective: !!formData.objective
      })
      return NextResponse.json(
        { error: 'Faltan datos requeridos' },
        { status: 400 }
      )
    }

    console.log('üîÑ Mapeando datos del formulario...')
    // Mapear datos del formulario
    let mappedData
    try {
      mappedData = mapFormDataToPrompt(formData)
      console.log('‚úÖ Datos mapeados correctamente')
    } catch (mappingError) {
      console.error('‚ùå Error mapeando datos:', mappingError)
      return NextResponse.json(
        { error: 'Error procesando datos del formulario' },
        { status: 400 }
      )
    }
    
    // Verificar si tenemos modelo fine-tuned configurado
    const finetunedModel = process.env.OPENAI_FINETUNED_MODEL
    console.log('ü§ñ Modelo fine-tuned configurado:', !!finetunedModel)
    console.log('ü§ñ Valor de OPENAI_FINETUNED_MODEL:', finetunedModel || 'NO CONFIGURADO')
    
    let generatedContent
    let response
    let generationMethod = 'unknown'
    
    console.log('üîÑ Iniciando generaci√≥n con OpenAI...')
    
    if (finetunedModel) {
      // Usar modelo fine-tuned (dos pasos)
      console.log('Usando modelo fine-tuned:', finetunedModel)
      
      try {
        // Usar fine-tune directamente para generar el art√≠culo completo
        const fineTunePrompt = `TONO: ${formData.tone}
TEMA: ${formData.topic}
ENFOQUE: ${formData.professionalFocus}
EXTENSI√ìN: ${formData.length}
OBJETIVO: ${formData.objective}`
        
        console.log('Prompt para fine-tune completo:', fineTunePrompt)
        
        response = await openai.chat.completions.create({
          model: finetunedModel,
          messages: [
            {
              role: "user",
              content: fineTunePrompt
            }
          ],
          max_tokens: 2000,
          temperature: 0.7
        })
        
        generatedContent = response.choices[0].message.content
        generationMethod = 'fine-tuned direct'
        console.log('‚úÖ Art√≠culo generado directamente con FINE-TUNE:', generatedContent.substring(0, 200) + '...')
        console.log('üéØ M√âTODO UTILIZADO: Fine-tuned model directo')
        console.log('üìä Respuesta del fine-tune:', {
          model: finetunedModel,
          usage: response.usage,
          finish_reason: response.choices[0].finish_reason
        })
      } catch (finetuneError) {
        console.error('‚ùå Error con modelo fine-tuned, usando fallback:', finetuneError)
        console.log('üîÑ CAUSAS POSIBLES: Modelo no disponible, API error, o configuraci√≥n incorrecta')
        // Fallback al m√©todo tradicional
        const prompt = createPrompt(mappedData)
        console.log('Prompt generado (fallback):', prompt)
        
        response = await openai.chat.completions.create({
          model: "gpt-4",
          messages: [
            {
              role: "user",
              content: prompt
            }
          ],
          max_tokens: 2000,
          temperature: 0.7
        })
        
        generatedContent = response.choices[0].message.content
        generationMethod = 'gpt-4 fallback (fine-tune error)'
        console.log('üîÑ Art√≠culo generado con M√âTODO TRADICIONAL (fallback)')
        console.log('üéØ M√âTODO UTILIZADO: GPT-4 est√°ndar (sin fine-tune)')
      }
    } else {
      // Usar m√©todo tradicional (fallback)
      console.log('‚ö†Ô∏è NO HAY MODELO FINE-TUNED - Usando modelo est√°ndar gpt-4')
      const prompt = createPrompt(mappedData)
      console.log('Prompt generado:', prompt)
      
      response = await openai.chat.completions.create({
        model: "gpt-4",
        messages: [
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 2000,
        temperature: 0.7
      })
      
      generatedContent = response.choices[0].message.content
      generationMethod = 'gpt-4 standard (no fine-tune configured)'
      console.log('üîÑ Art√≠culo generado con M√âTODO TRADICIONAL')
      console.log('üéØ M√âTODO UTILIZADO: GPT-4 est√°ndar (sin fine-tune configurado)')
    }
    
    // Validar que se gener√≥ contenido
    if (!generatedContent || !response.choices || !response.choices[0] || !response.choices[0].message) {
      console.error('Error: No se gener√≥ contenido v√°lido')
      return NextResponse.json(
        { error: 'No se pudo generar el contenido' },
        { status: 500 }
      )
    }
    
    // Procesar la respuesta para extraer art√≠culos
    const articles = processGeneratedContent(generatedContent, formData.resultsCount || 1)
    
    // Validar que tenemos art√≠culos antes de continuar
    if (!articles || articles.length === 0) {
      console.error('No se generaron art√≠culos:', generatedContent)
      return NextResponse.json(
        { error: 'No se pudieron generar art√≠culos v√°lidos' },
        { status: 500 }
      )
    }

    // Incrementar contador de uso seg√∫n el plan del usuario
    try {
      console.log('Obteniendo plan del usuario:', user.email)
      const userPlan = await getUserPlanFromDB(user.email)
      console.log('Plan obtenido:', userPlan)
      
      const tokensUsed = response.usage?.total_tokens || 0
      console.log('Tokens usados:', tokensUsed)
      
      if (userPlan && userPlan.id === 'trial') {
        // TRIAL: Solo incrementar art√≠culos (3 m√°ximo)
        console.log('Incrementando uso para usuario trial')
        await incrementArticleUsage(user.email)
      } else if (userPlan) {
        // PLANES PAGOS: Incrementar art√≠culos y tokens
        console.log('Incrementando uso para usuario pagado')
        await incrementArticleAndTokenUsage(user.email, tokensUsed)
      } else {
        console.log('Usuario sin plan v√°lido, permitiendo uso b√°sico')
      }
      
      // Guardar art√≠culos autom√°ticamente en la base de datos
      try {
        const client = await clientPromise
        const db = client.db(process.env.MONGODB_DB || 'miSaaS')
        const articlesCollection = db.collection('articles')
        
        console.log('Guardando art√≠culos en la base de datos...')
        for (const article of articles) {
          const articleDoc = {
            userId: user.email,
            title: article.title,
            body: article.content,
            status: 'draft',
            template: 'ai-generated',
            metadata: {
              tone: mappedData.tone || 'profesional',
              length: mappedData.length || 'medio',
              keywords: [mappedData.topic].filter(Boolean),
              tags: [mappedData.objective].filter(Boolean),
              targetAudience: mappedData.targetAudience || mappedData.audience || 'profesionales',
              estimatedReadTime: Math.ceil(article.wordCount / 200) || 1,
              wordCount: article.wordCount,
              generationData: {
                createdAt: new Date(),
                professionalFocus: mappedData.professionalFocus,
                aspects: mappedData.aspects
              }
            },
            createdAt: new Date(),
            updatedAt: new Date()
          }
          
          await articlesCollection.insertOne(articleDoc)
          console.log('Art√≠culo guardado:', article.title)
        }
        console.log('Todos los art√≠culos guardados correctamente')
      } catch (saveError) {
        console.error('Error guardando art√≠culos:', saveError)
        // No fallar la respuesta si hay error al guardar
      }
      
      // Obtener informaci√≥n actualizada de uso (sin fallar si hay error)
      let updatedUsageInfo = null
      try {
        updatedUsageInfo = await canUserGenerateContent(user.email, 'article')
      } catch (usageInfoError) {
        console.error('Error obteniendo info de uso:', usageInfoError)
      }
      
      return NextResponse.json({
        success: true,
        articles: articles,
        usage: response.usage || {},
        usageInfo: updatedUsageInfo,
        tokensUsed: tokensUsed,
        userPlan: userPlan?.id || 'unknown',
        generationMethod: generationMethod,
        finetunedModelConfigured: !!finetunedModel,
        finetunedModelName: finetunedModel || null
      })
    } catch (usageError) {
      console.error('Error tracking usage:', usageError)
      // No fallar la respuesta por error de tracking - devolver los art√≠culos
      return NextResponse.json({
        success: true,
        articles: articles,
        usage: response.usage || {},
        error: 'Error tracking usage but content generated',
        generationMethod: generationMethod,
        finetunedModelConfigured: !!finetunedModel,
        finetunedModelName: finetunedModel || null
      })
    }

  } catch (error) {
    console.error('Error generando art√≠culo:', error)
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      status: error.status,
      stack: error.stack
    })
    
    // Manejar errores espec√≠ficos de OpenAI
    if (error.code === 'insufficient_quota') {
      return NextResponse.json(
        { error: 'L√≠mite de API alcanzado', details: error.message },
        { status: 429 }
      )
    }
    
    if (error.code === 'invalid_api_key') {
      return NextResponse.json(
        { error: 'API Key inv√°lida', details: error.message },
        { status: 401 }
      )
    }
    
    if (error.code === 'model_not_found') {
      return NextResponse.json(
        { error: 'Modelo no encontrado', details: error.message },
        { status: 400 }
      )
    }
    
    return NextResponse.json(
      { 
        error: 'Error interno del servidor', 
        details: error.message,
        code: error.code 
      },
      { status: 500 }
    )
  }
}

// Funci√≥n para procesar el contenido generado y separar los art√≠culos
function processGeneratedContent(content, resultsCount) {
  const articles = []
  
  // Validar que tenemos contenido
  if (!content || typeof content !== 'string' || content.trim().length === 0) {
    console.error('Contenido generado est√° vac√≠o o inv√°lido:', content)
    return []
  }
  
  try {
    if (resultsCount === 1 || !resultsCount) {
      // Un solo art√≠culo - limpiar y formatear
      const cleanContent = cleanAndFormatContent(content)
      if (cleanContent && cleanContent.trim().length > 0) {
        articles.push({
          id: 1,
          title: extractTitle(cleanContent),
          content: cleanContent,
          wordCount: countWords(cleanContent)
        })
      }
    } else {
      // M√∫ltiples art√≠culos - separar por "---" o t√≠tulos
      const articleSections = content.split(/---+/).filter(section => section.trim())
      
      if (articleSections.length === 0) {
        // Si no se separ√≥ correctamente, usar todo el contenido como un art√≠culo
        const cleanContent = cleanAndFormatContent(content)
        if (cleanContent && cleanContent.trim().length > 0) {
          articles.push({
            id: 1,
            title: extractTitle(cleanContent),
            content: cleanContent,
            wordCount: countWords(cleanContent)
          })
        }
      } else {
        articleSections.forEach((section, index) => {
          if (section.trim()) {
            const cleanContent = cleanAndFormatContent(section.trim())
            if (cleanContent && cleanContent.trim().length > 0) {
              articles.push({
                id: index + 1,
                title: extractTitle(cleanContent),
                content: cleanContent,
                wordCount: countWords(cleanContent)
              })
            }
          }
        })
      }
    }
  } catch (processingError) {
    console.error('Error procesando contenido:', processingError)
    // Intentar devolver al menos el contenido b√°sico
    if (content && content.trim().length > 0) {
      articles.push({
        id: 1,
        title: 'Art√≠culo Generado',
        content: content.trim(),
        wordCount: countWords(content)
      })
    }
  }
  
  return articles
}

// Funci√≥n para limpiar y formatear el contenido
function cleanAndFormatContent(content) {
  if (!content || typeof content !== 'string') {
    return ''
  }
  
  try {
    return content
      .replace(/^#+\s*T√≠tulo[:\s]*/gmi, '') // Remover "T√≠tulo:" o "## T√≠tulo:"
      .replace(/^#+\s*Gancho inicial[:\s]*/gmi, '') // Remover "Gancho inicial:"
      .replace(/^#+\s*Cuerpo[:\s]*/gmi, '') // Remover "Cuerpo:"
      .replace(/^#+\s*Conclusi√≥n[:\s]*/gmi, '## Conclusi√≥n\n\n') // Limpiar "Conclusi√≥n:"
      .replace(/^#+\s*Hashtags[:\s]*/gmi, '') // Remover "Hashtags:"
      .replace(/\n{3,}/g, '\n\n') // Limitar saltos de l√≠nea m√∫ltiples
      .trim()
  } catch (error) {
    console.error('Error limpiando contenido:', error)
    return content || ''
  }
}

// Funci√≥n para extraer el t√≠tulo del contenido
function extractTitle(content) {
  if (!content || typeof content !== 'string') {
    return 'Art√≠culo Generado'
  }
  
  try {
    const titleMatch = content.match(/^#\s*(.+)$/m)
    return titleMatch ? titleMatch[1].trim() : 'Art√≠culo Generado'
  } catch (error) {
    console.error('Error extrayendo t√≠tulo:', error)
    return 'Art√≠culo Generado'
  }
}

// Funci√≥n para contar palabras
function countWords(text) {
  if (!text || typeof text !== 'string') {
    return 0
  }
  
  try {
    return text.split(/\s+/).filter(word => word.length > 0).length
  } catch (error) {
    console.error('Error contando palabras:', error)
    return 0
  }
}
